// lib/malware/providers.ts
import crypto from "node:crypto";

export type MalwareScanVerdict = {
  provider: "virustotal" | "metadefender";
  status: "PENDING" | "SCANNING" | "COMPLETED" | "FAILED";
  sha256: string;
  score?: number; // 0-100
  raw?: any;
  error?: string;
};

export function sha256Of(buf: Uint8Array | Buffer): string {
  return crypto.createHash("sha256").update(buf).digest("hex");
}

function clampScore(x: number) {
  return Math.max(0, Math.min(100, Math.round(x)));
}

function toBuffer(content: Uint8Array | Buffer): Buffer {
  return Buffer.isBuffer(content) ? content : Buffer.from(content);
}

// Node aceita Buffer como body; TS pode implicar -> cast controlado
function asBodyInit(b: Buffer): BodyInit {
  return b as unknown as BodyInit;
}

export async function scanWithVirusTotal(args: {
  sha256: string;
  filename: string;
  content: Uint8Array | Buffer;
  sizeBytes: number;
}): Promise<MalwareScanVerdict> {
  const apiKey = process.env.VIRUSTOTAL_API_KEY;
  if (!apiKey) {
    return { provider: "virustotal", status: "FAILED", sha256: args.sha256, error: "VIRUSTOTAL_API_KEY em falta" };
  }

  // 1) report por hash
  const reportRes = await fetch(`https://www.virustotal.com/api/v3/files/${args.sha256}`, {
    headers: { accept: "application/json", "x-apikey": apiKey },
    cache: "no-store",
  });

  if (reportRes.ok) {
    const j = await reportRes.json();
    const stats = j?.data?.attributes?.last_analysis_stats;
    const malicious = Number(stats?.malicious ?? 0);
    const suspicious = Number(stats?.suspicious ?? 0);
    const harmless = Number(stats?.harmless ?? 0);
    const undetected = Number(stats?.undetected ?? 0);
    const total = malicious + suspicious + harmless + undetected || 1;
    const score = clampScore(((malicious * 1.0 + suspicious * 0.7) / total) * 100);
    return { provider: "virustotal", status: "COMPLETED", sha256: args.sha256, score, raw: j };
  }

  // 2) upload binário direto (sem formdata)
  let uploadUrl = "https://www.virustotal.com/api/v3/files";
  if (args.sizeBytes > 32 * 1024 * 1024) {
    const u = await fetch("https://www.virustotal.com/api/v3/files/upload_url", {
      headers: { accept: "application/json", "x-apikey": apiKey },
      cache: "no-store",
    });
    if (!u.ok) {
      return { provider: "virustotal", status: "FAILED", sha256: args.sha256, error: "Falha ao obter upload_url do VT" };
    }
    const uj = await u.json();
    uploadUrl = String(uj?.data ?? uploadUrl);
  }

  const buf = toBuffer(args.content);

  // VT aceita upload raw; adicionamos filename no header para consistência
  const uploadRes = await fetch(uploadUrl, {
    method: "POST",
    headers: {
      accept: "application/json",
      "x-apikey": apiKey,
      "content-type": "application/octet-stream",
      "content-disposition": `attachment; filename="${encodeURIComponent(args.filename)}"`,
    },
    body: asBodyInit(buf),
  });

  if (!uploadRes.ok) {
    const t = await uploadRes.text().catch(() => "");
    return { provider: "virustotal", status: "FAILED", sha256: args.sha256, error: `Upload VT falhou: ${t}` };
  }

  const uploaded = await uploadRes.json();
  const analysisId = uploaded?.data?.id;
  if (!analysisId) {
    return { provider: "virustotal", status: "FAILED", sha256: args.sha256, error: "Sem analysisId do VT" };
  }

  // 3) polling
  for (let i = 0; i < 12; i++) {
    await new Promise((r) => setTimeout(r, 2000));

    const a = await fetch(`https://www.virustotal.com/api/v3/analyses/${analysisId}`, {
      headers: { accept: "application/json", "x-apikey": apiKey },
      cache: "no-store",
    });

    if (!a.ok) continue;
    const aj = await a.json();
    const status = aj?.data?.attributes?.status;

    if (status === "completed") {
      const final = await fetch(`https://www.virustotal.com/api/v3/files/${args.sha256}`, {
        headers: { accept: "application/json", "x-apikey": apiKey },
        cache: "no-store",
      });

      if (final.ok) {
        const j = await final.json();
        const stats = j?.data?.attributes?.last_analysis_stats;
        const malicious = Number(stats?.malicious ?? 0);
        const suspicious = Number(stats?.suspicious ?? 0);
        const harmless = Number(stats?.harmless ?? 0);
        const undetected = Number(stats?.undetected ?? 0);
        const total = malicious + suspicious + harmless + undetected || 1;
        const score = clampScore(((malicious * 1.0 + suspicious * 0.7) / total) * 100);
        return { provider: "virustotal", status: "COMPLETED", sha256: args.sha256, score, raw: j };
      }

      return { provider: "virustotal", status: "COMPLETED", sha256: args.sha256, score: 0, raw: aj };
    }
  }

  return { provider: "virustotal", status: "FAILED", sha256: args.sha256, error: "Timeout no VirusTotal" };
}

export async function scanWithMetaDefender(args: {
  sha256: string;
  filename: string;
  content: Uint8Array | Buffer;
}): Promise<MalwareScanVerdict> {
  const apiKey = process.env.METADEFENDER_API_KEY;
  if (!apiKey) {
    return {
      provider: "metadefender",
      status: "FAILED",
      sha256: args.sha256,
      error: "METADEFENDER_API_KEY em falta",
    };
  }

  const buf = toBuffer(args.content);

  // 1) upload
  const upload = await fetch("https://api.metadefender.com/v4/file", {
    method: "POST",
    headers: {
      apikey: apiKey,
      filename: args.filename,
      "content-type": "application/octet-stream",
      accept: "application/json",
    },
    body: asBodyInit(buf),
    cache: "no-store",
  });

  if (!upload.ok) {
    const t = await upload.text().catch(() => "");
    return {
      provider: "metadefender",
      status: "FAILED",
      sha256: args.sha256,
      error: `Upload MetaDefender falhou: ${t}`,
    };
  }

  const uj = await upload.json().catch(() => null);
  const dataId = uj?.data_id;
  if (!dataId) {
    return {
      provider: "metadefender",
      status: "FAILED",
      sha256: args.sha256,
      error: "Sem data_id do MetaDefender",
      raw: uj,
    };
  }

  // 2) polling robusto (com timeout real)
  const startedAt = Date.now();
  const TIMEOUT_MS = 2 * 60 * 1000; // 2 min por ficheiro (ajusta)
  const SLEEP_MS = 2500;

  while (Date.now() - startedAt < TIMEOUT_MS) {
    await new Promise((r) => setTimeout(r, SLEEP_MS));

    const rres = await fetch(`https://api.metadefender.com/v4/file/${dataId}`, {
      headers: { apikey: apiKey, accept: "application/json" },
      cache: "no-store",
    });

    // rate limit/instável -> continua
    if (rres.status === 429 || rres.status === 502 || rres.status === 503) continue;
    if (!rres.ok) continue;

    const rj = await rres.json().catch(() => null);
    if (!rj) continue;

    const scan = rj?.scan_results;
    const ai = scan?.scan_all_result_i; // <- normalmente é o mais fiável
    const aa = String(
      scan?.scan_all_result_a ??
        scan?.scan_all_result ??
        scan?.scan_all_result_s ??
        ""
    ).toLowerCase();

    // Alguns dumps trazem percentagens
    const pct =
      Number(scan?.progress_percentage ?? rj?.process_info?.progress_percentage ?? NaN);

    // Estados comuns (pela doc/observação):
    // scan_all_result_i:
    // 0 = clean, 1 = infected, 2 = no result / unknown, 3 = in progress, 4 = queued (varia)
    const i = typeof ai === "number" ? ai : Number(ai);

    const doneByInt = Number.isFinite(i) && (i === 0 || i === 1 || i === 2);
    const doneByStr =
      aa.includes("clean") ||
      aa.includes("infected") ||
      aa.includes("no result") ||
      aa.includes("unknown");

    const inProgress =
      (Number.isFinite(i) && (i === 3 || i === 4)) ||
      aa.includes("in progress") ||
      aa.includes("queued") ||
      (Number.isFinite(pct) && pct < 100);

    if (!doneByInt && !doneByStr) {
      // se não dá para concluir mas parece estar a processar, continua
      if (inProgress) continue;

      // caso “estranho”: continua mais um pouco
      continue;
    }

    // concluiu
    const infected = (Number.isFinite(i) && i === 1) || aa.includes("infected");
    const clean = (Number.isFinite(i) && i === 0) || aa.includes("clean");

    // score
    let score = 50; // unknown/no result
    if (infected) score = 100;
    else if (clean) score = 0;

    return {
      provider: "metadefender",
      status: "COMPLETED",
      sha256: args.sha256,
      score,
      raw: rj,
    };
  }

  return {
    provider: "metadefender",
    status: "FAILED",
    sha256: args.sha256,
    error: "Timeout no MetaDefender",
  };
}